<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8"/>
    <title>A Pint-sized Earley Parser</title>
    <script src="earley.js"></script>
    <link rel="stylesheet" href="style.css">
</head>
<body>

<div id="content">

<h1>A Pint-sized Earley Parser</h1>

<p>Many people have said that convenient parser generation is a
game-changing technology.  In his talk <em>To Trap a Better Mouse</em>,
Ian Piumarta <a href="https://youtu.be/EGeN2IC7N0Q?t=41m">suggested</a>
that the Earley algorithm is a good place to start because it handles
full context-free grammars and is fairly trivial to implement.  But some
parts of the algorithm (particularly the construction of the parse
forest) don't seem to have good descriptions which are easily accessible
to non-experts.</p>

<p>So this is an attempt to fill that gap: a trivial realization of the
algorithm, suitable for implementation in an afternoon, and with an
annotated version for easy understanding and porting.  I'm deliberately
being fairly concise: for more information try Loup Vaillant-David's <a
href="http://loup-vaillant.fr/tutorials/earley-parsing/">Earley Parsing
Explained</a> which goes into far more detail.</p>

<p>This is annotated pseudocode.  I was going to annotate the
JavaScript, but JavaScript has a lot of "noise", so I reduced it to
pseudocode for readability.  The <a href="earley.js">JavaScript
source</a> is available if you prefer that.  The git repository for this
project is at <a
href="https://github.com/JoshuaGrams/pep">github.com/JoshuaGrams/pep</p>

<ul>
    <li><a href="#recognizer">The Recognizer</a></li>
    <ul>
        <li><a href="#data-structures">Data Structures</a></li>
        <li><a href="#algorithm">The Algorithm</a></li>
    </ul>
    <li><a href="#parser">The Parser</a></li>
	<li><a href="#demo">A Trivial Demonstration</a></li>
    <li><a href="#future">Future Work</a></li>
</ul>

<h2><a name="recognizer">The Recognizer</a></h2>

<p class="note">Note: This part of the algorithm is well-covered: the
presentation in Aycock and Horspool's <a
href="http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.12.4254">Practical
Earley Parsing</a> is excellent, and <a
href="https://en.wikipedia.org/wiki/Earley_parser">Wikipedia's entry</a>
isn't too bad.  But I am using a modified formulation which builds only
one set at once, adds additional items which will be useful for the
parser, and does not make a distinction between terminal and
non-terminal symbols, so you probably want to read this section
anyway.</p>


<h3><a name="data-structures">Data Structures</a></h3>

<p>Let's start with some basic data structures.  A <strong>Rule</strong>
has a symbol on the left hand side, and an array of symbols on the
right.  A <strong>Grammar</strong> has a start symbol and a set of rules
indexed by symbol.  Note that there may be multiple rules for the same
symbol: this is the only way that we support alternatives in rules.</p>

<pre><code>Rule : { String symbol, Array production }

Grammar : {
    String start,
    Dictionary([Rule]) rules
        // { "S": [S -&gt; X Y, S -&gt; A A b], ...}
}</code></pre>

<p>An <strong>LR(0) item</strong> represents a partially matched rule
and is generally written with a dot showing the end of the match, so
<code class="no-wrap">S &#8594; Expression "+" &bull; Term</code> would
indicate that an <code>Expression</code> and <code>"+"</code> have been
matched.</p>

<code><pre>LR0 : { Rule rule, Integer dot }
next_symbol(lr0) =
    if(lr0.dot &lt; lr0.rule.length) rule.production[rule.dot]</pre></code>

<p>In this implementation we never use complete LR(0) items: we always
promote them to a symbol so that all parse trees for a symbol will be
combined under one Earley item no matter which production they derive
from.</p>

<pre><code>advance(lr0) =
    if(lr0.dot == lr0.rule.length) lr0.rule.symbol
    else new LR0(lr0.rule, lr0.dot+1)</code></pre>

<p>Earley's algorithm works by keeping a table of all possible matches,
both partial and complete.  These are organized into <strong>Earley
sets</strong> by the input position where the match ends.  My sets also
contain a couple of indices and a reference to the grammar so we can
quickly find the items and rules we need to look at.</p>

<p>An <strong>Earley item</strong> consists of a symbol (for complete
matches) or an LR(0) item (for partial matches) plus references to the
sets (and hence input positions) where the match starts and ends.</p>

<pre><code>Item : { Symbol | LR0 : tag, Set start, Set end }

Set : {
    Grammar grammar,
    Integer position,  // index into the input sequence
    Array items,       // items for iteration/processing
    Dictionary idx,    // items by tag and start for uniqueness
    Dictionary wants,  // incomplete items by next symbol
} 

append_item(tag, start, end) =
    item = new Item(tag, start, end)
    end.items.push(item)
    end.idx[tag][start] = item
    if(tag.is_lr0) end.wants[tag.rule.symbol].push(item)
    item  // return item</code></pre>

<p>To preserve uniqueness we only call <code>append_item</code> if the
item doesn't already exist.</p>

<pre><code>add_item(tag, start, end) =
    end.idx[tag][start] || append_item(tag, start, end)</code></pre>


<h3><a name="algorithm">The Algorithm</a></h3>

<p>We start with an initial set containing rules for the start symbol
and any items derived from those.  Then we build a set for each
successive input symbol.  When we reach the end of the string, if we
have a complete item for the start symbol matching the entire string
then the parse has succeeded.</p>

<pre><code>parse(grammar, input) =
    s0 = process(predict(new Set(grammar, 0), grammar.start))
    sN = foldl(parse_symbol, s0, input)
    sN.idx[grammar.start][0]

parse_symbol(set, sym) = process(scan(set, sym))</code></pre>

<p>Like most parsers, Earley's works from both ends. It
<em>predicts</em> which rules to match from the top down, but
<em>completes</em> matches from the bottom up.</p>

<p>Prediction makes new LR(0) items (with the dot at the beginning) from
each of a symbol's rules.</p>

<pre><code>predict(set, sym) =
    for rule in set.grammar.rules[sym]
        add_item(new LR0(rule, 0), set, set)
</code></pre>

<p>When an item is complete, we look back to the set where it started
and advance any partial items there which were looking for the completed
symbol.</p>

<pre><code>complete(set, complete) =
    for item in complete.start.wants[complete.tag]
        add_item(advance(item.tag), item.start, complete.end)</code></pre>

<p>To initialize a new set, we <em>scan</em> an input symbol, adding an
item for that symbol.  Note that the traditional Earley algorithm does
<em>not</em> have items for terminals, and the scan operation advances
all items which are looking for the input symbol.  But it's convenient
to have an item for the input symbol when creating the parse forest.
And since we don't distinguish between terminal and non-terminal
symbols, our scan can just add a single item for the input symbol and
let the completer do all the advancing.</p>

<pre><code>scan(set1, sym) =
    set2 = new Set(set1.grammar, set1.position + 1)
    add_item(sym, set1, set2)
    set2  // return the new set</code></pre>

<p>Then we process items recursively with <code>predict()</code> and
<code>complete()</code>.  We predict rules for the next symbol of any
partial matches, and to look back and advance items which match any
newly completed items.</p>

<pre><code>process_once(set) =
    for(item in set.items)  // including newly-added ones
        if(item.tag.is_lr0) predict(set, next_symbol(item.tag))
        else complete(item)</code></pre>

<p>If there are rules which produce the empty string, this may fail to
produce all the necessary items (see Aycock and Horspool's <a
href="http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.12.4254">Practical
Earley Parsing</a> for more info).  There are better ways to deal with
this, but we're just going to keep trying again until it fails to add
any items.</p>

<pre><code>process(set) =
    old = set.items.length
    do  process_once(set)  while(set.items.length &gt; old)
    set  // return the set for foldl's convenience</code></pre>



<h2><a name="parser">The Parser</a></h2>

<p>To extend the parser to a recognizer, we add a shared packed parse
forest (SPPF) node to each Earley item, as described in Elizabeth
Scott's paper <a
href="http://www.sciencedirect.com/science/article/pii/S1571066108001497">SPPF-style
Parsing from Earley Recognizers</a>.  She uses a pointer to a separate
object, but I am using the Earley items themselves as parse forest
nodes.</p>

<p>Scanning produces input symbol nodes which are their own derivation.
Predictions start with no derivations.  The completer appends the
derivation of the newly completed symbol to the derivation of the item
it is advancing.  So we just need to augment the Earley items with two
pointers: a <em>left</em> pointer to the previous Earley item (if any)
and a <em>right</em> pointer to the new item.</p>

<p>The <code>scan</code> and <code>predict</code> routines are
unchanged, since they add nodes with no derivation.  But
<code>complete</code> needs to (potentially) add a new derivation,
regardless of whether it adds a new item.</p>

<pre><code>complete(set, complete) =
    for item in complete.start.wants[complete.tag]
        <span class="inserted">a = </span>add_item(advance(item.tag), item.start, complete.end)
        <span class="inserted">add_derivation(a, item, complete)</span></code></pre>

<p>The contents of the parse pointers fall into three classes:</p>

<table class="center">
    <tr><th>Links</th><th>Meaning</th></tr>
    <tr><td>null/null</td><td>no derivations</td></tr>
    <tr><td>null/item<br>item/item</td><td>single derivation</td></tr>
    <tr><td>list/null</td><td>multiple derivations</td></tr>
</table>

<p>Items with ambiguous parses have a linked list of objects, each of
which represents one derivation.</p>

<pre><code>Derivation : { Item left, Item right, Derivation next }</code></pre>

<p><code>add_derivation</code> needs to handle each of the three
classes.  It also removes some unnecessary nodes on the left edge of the
tree.  If the left child is an LR(0) item with one or no children, then
we skip it and use its child (if any) directly.</p>

<pre><code>add_derivation(item, left, right) {
    if(!(left || right)) return  // empty derivation

    // remove trivial nodes on the left
    if(left.tag.is_lr0 and left.tag.dot &lt;= 1) left = left.right

    if(!(item.left || item.right)) set_derivation(item, left, right)
    else if(item.right) add_second_derivation(item, left, right)
    else add_another_derivation(item, left, right)</code></pre>

<p>If there aren't any derivations yet, we just set the new one.  But if
there <em>are</em> existing derivations we'll need to check whether the
new one is already present.</p>

<pre><code>set_derivation(item, left, right) =
    item.left = left
    item.right = right

same_derivation(item, left, right) =
    item.left == left &amp;&amp; item.right == right</code></pre>

<p>If there is one existing derivation, we need to turn it into a list
of one item and then add the new one.</p>

<pre><code>add_second_derivation(item, left, right) =
    if(!same_derivation(item, left, right))
        old = new Derivation(item.left, item.right, null)
        item.left = new Derivation(left, right, old)
        item.right = null</code></pre>

<p>Finally, if there are multiple existing derivations, we need to
search the list to see if the derivation is present.</p>

<pre><code>add_another_derivation(item, left, right) =
    d = item.left;  while(d)
        if(same_derivation(d, left, right)) return
        d = d.next
    item.left = new Derivation(left, right, item.left)</code></pre>



<h2><a name="demo">A Trivial Demonstration</a></h2>

<pre><code>g = Grammar('S',
	S -&gt; X X b
	X -&gt;
	X -&gt; a
	X -&gt; a a
	X -&gt; a a a)

parse(g, 'aaab')</code></pre>

<div id="forest"></div>
<script src="forest.js"></script>
<script>
var g = new Grammar('S', [
		new Rule('S', ['X', 'X', 'b']),
		new Rule('X', []),
		new Rule('X', ['a']),
		new Rule('X', ['a', 'a']),
		new Rule('X', ['a', 'a', 'a'])
		]);
var f = g.parse('aaab');
var hf = forest_to_html(f);
hf.className = 'center';
document.getElementById('forest').appendChild(hf);
</script>


<h2><a name="future">Future Work</a></h2>

<p>I'm excited about finally getting this algorithm figured out and running, so
I'm writing it up and posting it right away.  But to be at all "finished" it
needs a means to enter grammars in a convenient notation, a way to choose a
parse tree from the forest, and a way to attach actions to rules.  I hope to
get to this soon, but realistically it might be a month or three before I get
around to finishing all of it.</p>

</div>

</body>
</html>
